.=torg +1000
main:mov pc,sp
tst -(sp)

mov #0,Score
mov #Moves, r0

check_12:
	cmpb (r0),#'@		;first we check if the
	beq Movesdone		;series of commands finished
	add #1,Score		
	movb (r0)+, r1		;we are putting the values
	movb (r0)+, r3		;of the current command
	movb (r0)+, r5		;into the registers
	
	mov #0,Fail			;we now check if the
	cmp nRows, r1		;values are in the correct
	blos Illegal		;range. if not, game will 
	mov #0, Start_Row	;end by branching to Illegal, 
	add r1, Start_Row	;and Fail will be 0
	cmp nCols, r3
	blos Illegal
	br check_3

check_3: 
	mov #1, Fail		;now we check if the
	mul nCols, r1		;player picked a spot
	add r3, r1			;on the board that has
	add #Board, r1		;an object that is legal to
	cmpb (r1), #'A		;move. if not, game will end
	beq check_4			;and Fail will be 1.
	cmpb (r1), #'R
	beq check_4
	br Illegal

check_4:
	mov #2,Fail			;now we check if the
	cmp r5, #'R			;direction chosen to move 
	beq right			;is legal. if not, score will
	cmp r5, #'L			;be 2 and game will end.
	beq left			
	cmp r5, #'D
	beq down
	cmp r5, #'U
	beq up
	br Illegal

Illegal: 
		mov Fail,Score	;if any move was illegal, F' is
		mov #'F, Output	;put into output, and Fail into 
		halt			;Score
	
Movesdone:
		clr r3			;after moves are done, we will check if we
		clr r5			;are in the correct spot: we put the values
		mov #Finish, r0	;of 'finish' into registers, and compare
		movb (r0)+, r3	;them with our current spot on the board.
		movb (r0), r5	;if we're not in the correct spot, score will be 3.
		mul nCols, r3	
		add r5, r3
		add #Board, r3
		cmp r3,r1
		beq Success 
		mov #3, Fail
		jmp Illegal	
	
down:
	movb (r1), r2		 ;down is a loop that moves the object
	clrb (r1)			 ;being moved down one space on the 
	add nCols,r1		 ;board at a time. after every space 
	add #1, Start_Row	 ;moved it will check that the object hasn't
	cmp nRows, Start_Row ;left the board, and if the object has reached
	blos Illegal		 ;another object that will stop it.
	cmpb (r1), #0
	bne fin_mov4		 ;if next spot down is another object
	movb r2, (r1)		 ;branch to fin_mov4 to end move, if next spot is 0
	br down				 ;then it will branch to down loop again.
	
up: 
	movb (r1), r2		 ;up is a loop that moves the object
	clrb (r1)			 ;being moved up one space on the board at a time. after
	sub nCols,r1 		 ;every space moved it will check that the object hasn't
	sub #1, Start_Row	 ;left the board (by reducing Start_Row by 1 after each 
	cmp nRows, Start_Row ;move), and if the object has reached another object  
	blos Illegal		 ;that will stop it.
	cmpb (r1), #0		  
	bne fin_mov3		 ;if next spot down is another object
	movb r2, (r1)		 ;branch to fin_mov3 to end move, if next spot is 0
	br up				 ;then it will branch to up loop again.
	
right: 
	movb (r1),r2		;right is a loop like up and down. r3 currently has the 
	clrb (r1)			;value of the Collum we start at. by increasing the
	add #1, r3			;value of r3 by one and comparing it with nCols we check
	cmp nCols, r3		;if we left the board.
	blos Illegal
	add #1, r1
	cmpb (r1), #0
	bne fin_mov			;if next spot isnt 0, branch to fin_mov to end move
	movb r2, (r1)
	br right

left:
	movb (r1), r2		;right is a loop that works the same as up, down and
	clrb (r1)			;right. r3 currently has the value of the column we
	sub #1, r3			;start at by increasing the value of r3 by one and 
	cmp nCols, r3		;comparing it with nCols we check if we left the board.
	blos Illegal
	sub #1, r1
	cmpb (r1), #0
	bne fin_mov2		;if next spot isnt 0, branch to fin_mov2 to end move
	movb r2, (r1)
	br left		

fin_mov4:
		sub nCols, r1	;we need to return the Astronaut/robot one space
		movb r2, (r1)	;up, so we reduce nCols so that r1 points exactly one 
		jmp check_12	;row up, and then move the value of r2 (which holds 'A 
						;/'R) there. Then jump to next move.
fin_mov3: 
		add nCols, r1	;we need to return the Astronaut/robot one space
		movb r2, (r1)	;down, so we add nCols so that r1 points exactly one row
		jmp check_12	;dowb and then move the value of r2 (which holds 'A/'R) 
						;there. Then jump to next move.
fin_mov:
		movb r2, -(r1)	;we need to return the Astronaut/robot one space
		jmp check_12	;left, so we reduce 1 from r1 so that r1 points exactly 
						;one space left. then jump to next move.
fin_mov2:
		add #1, r1		;we need to return the Astronaut/robot one space
		movb r2, (r1)	;right, so we add 1 to r1 so that r1 points exactly 
		jmp check_12	;one space right. then jump to next move.	
		
Success:				 ;if moves are done and we are in the space set as
		movb #'S, Output ;Finish. we move ‘S‘ to Output and finish the game	.	
		halt

Fail: .word 0			;Fail is a variable that holds the reason of failure.
Start_Row: .word 0		;Start_Row holds the starting row of the current command
						;and helps in each branch to see if we left board.

		
		